# ClickIt Fastlane Configuration
# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools

# Suppress warnings and analytics
opt_out_usage
skip_docs

default_platform(:mac)

# Global configuration
APP_NAME = "ClickIt"
BUNDLE_ID = "com.jsonify.clickit"
DIST_DIR = "dist"

platform :mac do
  desc "Build ClickIt Pro app (Debug)"
  lane :build_debug do
    Dir.chdir("..") do
      sh("./build_app_unified.sh debug spm pro")

      # Apply adhoc signature if no certificate was found
      app_path = "dist/ClickIt.app"
      if File.exist?(app_path)
        begin
          # Check if app is already properly signed
          sh("codesign -v '#{app_path}' 2>/dev/null")
          UI.message("‚úÖ App already properly signed")
        rescue
          UI.message("üîê Applying adhoc signature for local development...")
          sh("codesign --force --deep --sign - --timestamp=none --options=runtime '#{app_path}'")
          UI.success("‚úÖ Adhoc signature applied successfully")
        end
      end
    end
    UI.success("Debug build completed! üéâ")
    UI.message("App location: dist/ClickIt.app")
  end

  desc "Build ClickIt Pro app (Release)"
  lane :build_release do
    Dir.chdir("..") do
      sh("./build_app_unified.sh release spm pro")

      # Apply adhoc signature if no certificate was found
      app_path = "dist/ClickIt.app"
      if File.exist?(app_path)
        begin
          # Check if app is already properly signed
          sh("codesign -v '#{app_path}' 2>/dev/null")
          UI.message("‚úÖ App already properly signed")
        rescue
          UI.message("üîê Applying adhoc signature for local development...")
          sh("codesign --force --deep --sign - --timestamp=none --options=runtime '#{app_path}'")
          UI.success("‚úÖ Adhoc signature applied successfully")
        end
      end
    end
    UI.success("Release build completed! üöÄ")
    UI.message("App location: dist/ClickIt.app")
  end

  desc "Build ClickIt Lite app (Debug)"
  lane :build_lite_debug do
    Dir.chdir("..") do
      sh("./build_app_unified.sh debug spm lite")

      # Apply adhoc signature if no certificate was found
      app_path = "dist/ClickIt Lite.app"
      if File.exist?(app_path)
        begin
          # Check if app is already properly signed
          sh("codesign -v '#{app_path}' 2>/dev/null")
          UI.message("‚úÖ App already properly signed")
        rescue
          UI.message("üîê Applying adhoc signature for local development...")
          sh("codesign --force --deep --sign - --timestamp=none --options=runtime '#{app_path}'")
          UI.success("‚úÖ Adhoc signature applied successfully")
        end
      end
    end
    UI.success("ClickIt Lite debug build completed! üéâ")
    UI.message("App location: dist/ClickIt Lite.app")
  end

  desc "Build ClickIt Lite app (Release)"
  lane :build_lite_release do
    Dir.chdir("..") do
      sh("./build_app_unified.sh release spm lite")

      # Apply adhoc signature if no certificate was found
      app_path = "dist/ClickIt Lite.app"
      if File.exist?(app_path)
        begin
          # Check if app is already properly signed
          sh("codesign -v '#{app_path}' 2>/dev/null")
          UI.message("‚úÖ App already properly signed")
        rescue
          UI.message("üîê Applying adhoc signature for local development...")
          sh("codesign --force --deep --sign - --timestamp=none --options=runtime '#{app_path}'")
          UI.success("‚úÖ Adhoc signature applied successfully")
        end
      end
    end
    UI.success("ClickIt Lite release build completed! üöÄ")
    UI.message("App location: dist/ClickIt Lite.app")
  end

  desc "Build and run ClickIt Pro app"
  lane :launch do
    build_debug
    Dir.chdir("..") do
      sh("./run_clickit_unified.sh app")
    end
    UI.success("ClickIt Pro launched! üñ±Ô∏è")
  end

  desc "Build and run ClickIt Lite app"
  lane :launch_lite do
    build_lite_debug
    Dir.chdir("..") do
      sh("open 'dist/ClickIt Lite.app'")
    end
    UI.success("ClickIt Lite launched! üñ±Ô∏è")
  end

  desc "Clean build artifacts"
  lane :clean do
    UI.message("Cleaning build artifacts...")
    Dir.chdir("..") do
      sh("rm -rf dist/*")
    end
    sh("rm -rf ~/Library/Developer/Xcode/DerivedData/ClickIt-*") rescue nil
    UI.success("Clean completed! üßπ")
  end

  desc "Verify code signing status"
  lane :verify_signing do
    Dir.chdir("..") do
      app_path = "dist/ClickIt.app"
      
      if File.exist?(app_path)
        UI.message("Checking code signing status...")
        
        begin
          sh("codesign --verify --verbose '#{app_path}'")
          UI.success("‚úÖ App is properly code signed")
        rescue
          UI.important("‚ö†Ô∏è  App is not code signed or signature is invalid")
        end
        
        # Show certificate info
        begin
          result = sh("codesign -dv '#{app_path}' 2>&1", log: false)
          UI.message("Code signing details:")
          UI.message(result)
        rescue
          UI.error("Could not retrieve signing details")
        end
      else
        UI.error("App not found at #{app_path}. Build first with 'fastlane build_debug' or 'fastlane build_release'")
      end
    end
  end

  desc "Show app bundle information"
  lane :info do
    Dir.chdir("..") do
      app_path = "dist/ClickIt.app"
      
      if File.exist?(app_path)
        UI.header("ClickIt App Bundle Information")
        
        # App size
        size = sh("du -sh '#{app_path}' | cut -f1", log: false).strip
        UI.message("üì¶ Bundle size: #{size}")
        
        # Version info from Info.plist
        begin
          version = sh("plutil -extract CFBundleShortVersionString xml1 -o - '#{app_path}/Contents/Info.plist' | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'", log: false).strip
          build = sh("plutil -extract CFBundleVersion xml1 -o - '#{app_path}/Contents/Info.plist' | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'", log: false).strip
          UI.message("üè∑Ô∏è  Version: #{version} (#{build})")
        rescue
          UI.message("Could not read version information")
        end
        
        # Architectures
        begin
          archs = sh("lipo -info '#{app_path}/Contents/MacOS/ClickIt' 2>/dev/null || file '#{app_path}/Contents/MacOS/ClickIt'", log: false)
          UI.message("üèóÔ∏è  Architecture: #{archs.strip}")
        rescue
          UI.message("Could not determine architecture")
        end
        
        # Permissions check
        UI.message("üîí Required permissions:")
        UI.message("   ‚Ä¢ Accessibility (for mouse events)")
        UI.message("   ‚Ä¢ Screen Recording (for window detection)")
      else
        UI.error("App not found at #{app_path}. Build first with 'fastlane build_debug' or 'fastlane build_release'")
      end
    end
  end

  desc "Full release workflow"
  lane :release do
    UI.header("Starting ClickIt Release Workflow")
    
    # Clean first
    clean
    
    # Build release version
    build_release
    
    # Verify signing
    verify_signing
    
    # Show final info
    info
    
    UI.success("üéâ Release workflow completed!")
    UI.message("Your app is ready at: dist/ClickIt.app")
    UI.message("Next steps:")
    UI.message("  ‚Ä¢ Test the app thoroughly")
    UI.message("  ‚Ä¢ Consider notarization for distribution")
    UI.message("  ‚Ä¢ Package into DMG if needed")
  end

  desc "Development workflow"
  lane :dev do
    UI.header("Starting ClickIt Development Workflow")
    
    # Validate and auto-sync version before development
    begin
      UI.message("üîç Checking version synchronization...")
      validate_github_sync
      UI.success("‚úÖ Version already synchronized")
    rescue => exception
      UI.message("‚ö†Ô∏è  Version mismatch detected: #{exception.message}")
      UI.message("üîÑ Auto-syncing version with GitHub release...")
      
      begin
        sync_version_with_github(auto_sync: true)
        UI.success("‚úÖ Version automatically synchronized for development")
      rescue => sync_exception
        UI.error("‚ùå Auto-sync failed: #{sync_exception.message}")
        UI.message("üí° Manual fix required: ./scripts/sync-version-from-github.sh")
        UI.message("üîÑ Continuing with development workflow anyway...")
      end
    end
    
    # Build debug and run
    launch
    
    UI.success("Development session started! üõ†Ô∏è")
    UI.message("The app should now be running")
  end

  # Advanced release lanes for future use
  desc "Build ClickIt for local development and testing"
  lane :local do
    UI.header "üî® Building ClickIt for Local Development"
    
    # Build the app bundle
    build_release
    
    UI.success "‚úÖ Local build complete!"
    UI.message "üìÇ Location: #{DIST_DIR}/#{APP_NAME}.app"
    UI.message "üöÄ Launch with: open \"#{DIST_DIR}/#{APP_NAME}.app\""
  end

  desc "Create beta release on staging branch with beta-* tag"
  lane :beta do
    UI.header "üöÄ Creating Beta Release"
    
    # Use Makefile beta workflow (includes validation, build, and GitHub release)
    Dir.chdir("..") do
      sh("make beta")
    end
    
    UI.success "‚úÖ Beta release created!"
    UI.message "Check your GitHub releases for the beta"
  end

  desc "Create production release on main branch with v* tag"
  lane :prod do
    UI.header "üéâ Creating Production Release"
    
    # Use Makefile prod workflow (includes validation, build, and GitHub release)
    Dir.chdir("..") do
      sh("make prod")
    end
    
    UI.success "‚úÖ Production release created!"
    UI.message "Your production release is now live on GitHub"
  end

  # Automated tagging lanes
  desc "Create and publish automated beta release with auto-generated tag"
  lane :auto_beta do |options|
    UI.header "ü§ñ Automated Beta Release"
    
    # Ensure we're in the project root (handle both cases: called from fastlane/ or project root)
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      # Validate we're on staging branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "staging"
        UI.user_error!("‚ùå Auto beta releases must be created from 'staging' branch. Current: #{current_branch}")
      end
      
      # Check for uncommitted changes
      git_status = sh("git status --porcelain", log: false).strip
      unless git_status.empty?
        UI.user_error!("‚ùå You have uncommitted changes. Please commit or stash them first.")
      end
      
      # Generate beta tag
      timestamp = Time.now.strftime("%Y%m%d%H%M")
      version = options[:version] || "1.0.0"
      beta_tag = "beta-v#{version}-#{timestamp}"
      
      UI.message "üè∑Ô∏è  Creating tag: #{beta_tag}"
      
      # Create and push tag
      sh("git tag #{beta_tag}")
      sh("git push origin #{beta_tag}")
      
      UI.success "‚úÖ Tag created and pushed: #{beta_tag}"
      
      # Now run the beta release
      sh("make beta")
    end
    
    UI.success "‚úÖ Automated beta release completed!"
    UI.message "Check your GitHub releases for the beta"
  end

  desc "Create and publish automated production release with auto-generated tag"
  lane :auto_prod do |options|
    UI.header "ü§ñ Automated Production Release"
    
    # Ensure we're in the project root (handle both cases: called from fastlane/ or project root)
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      # Validate we're on main branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "main"
        UI.user_error!("‚ùå Auto production releases must be created from 'main' branch. Current: #{current_branch}")
      end
      
      # Check for uncommitted changes
      git_status = sh("git status --porcelain", log: false).strip
      unless git_status.empty?
        UI.user_error!("‚ùå You have uncommitted changes. Please commit or stash them first.")
      end
      
      # Generate production tag
      version = options[:version] || "1.0.0"
      prod_tag = "v#{version}"
      
      # Check if tag already exists
      tag_exists = false
      begin
        sh("git rev-parse --verify #{prod_tag} >/dev/null 2>&1", log: false)
        tag_exists = true
      rescue
        # Tag doesn't exist, which is what we want
      end
      
      if tag_exists
        UI.message "üè∑Ô∏è  Tag #{prod_tag} already exists, skipping tag creation"
      else
        UI.message "üè∑Ô∏è  Creating tag: #{prod_tag}"
        # Create and push tag
        sh("git tag #{prod_tag}")
        sh("git push origin #{prod_tag}")
        UI.success "‚úÖ Tag created and pushed: #{prod_tag}"
      end
      
      # Now run the production release
      sh("make prod")
    end
    
    UI.success "‚úÖ Automated production release completed!"
    UI.message "Your production release is now live on GitHub"
  end

  desc "Bump version and create automated production release"
  lane :bump_and_release do |options|
    UI.header "üìà Version Bump and Release"
    
    # Ensure we're in the project root
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    new_version = nil
    
    Dir.chdir(project_root) do
      # Validate we're on main branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "main"
        UI.user_error!("‚ùå Version bumps must be done from 'main' branch. Current: #{current_branch}")
      end
      
      # Get current version from git tags (highest semantic version)
      begin
        # Get all version tags and find the highest semantic version
        all_tags = sh("git tag -l 'v*' | grep -E '^v[0-9]+\\.[0-9]+\\.[0-9]+$' | sort -V | tail -1", log: false).strip
        if all_tags.empty?
          latest_tag = "v0.0.0"
        else
          latest_tag = all_tags
        end
        current_version = latest_tag.gsub(/^v/, "")
      rescue
        current_version = "0.0.0"
      end
      
      UI.message "üìã Current version: #{current_version}"
      
      # Parse version components
      version_parts = current_version.split(".").map(&:to_i)
      major, minor, patch = version_parts[0] || 0, version_parts[1] || 0, version_parts[2] || 0
      
      # Determine bump type
      bump_type = options[:bump] || "patch"
      case bump_type
      when "major"
        major += 1
        minor = 0
        patch = 0
      when "minor"
        minor += 1
        patch = 0
      when "patch"
        patch += 1
      else
        UI.user_error!("‚ùå Invalid bump type: #{bump_type}. Use 'major', 'minor', or 'patch'")
      end
      
      new_version = "#{major}.#{minor}.#{patch}"
      UI.message "üÜô New version: #{new_version}"
      
      # Ask for confirmation unless forced
      unless options[:force]
        answer = UI.confirm("Create release for v#{new_version}?")
        unless answer
          UI.message "‚ùå Release cancelled by user"
          next
        end
      end
    end
    
    # Run auto production release with new version (this will handle its own directory context)
    auto_prod(version: new_version)
  end

  desc "üîç Validate GitHub version synchronization"
  lane :validate_github_sync do
    UI.header "üîç GitHub Version Validation"
    
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      begin
        # Get versions
        plist_version = sh("/usr/libexec/PlistBuddy -c 'Print CFBundleShortVersionString' ClickIt/Info.plist", log: false).strip
        github_tag = sh("gh release list --limit 1 --json tagName --jq '.[0].tagName'", log: false).strip
        github_version = github_tag.gsub(/^v/, '')
        
        UI.message("üìã Version Status:")
        UI.message("   Info.plist (UI): #{plist_version}")
        UI.message("   GitHub Release: #{github_version}")
        
        if plist_version != github_version
          UI.error("")
          UI.error("‚ùå VERSION MISMATCH DETECTED!")
          UI.error("   The UI will show v#{plist_version}")
          UI.error("   But the latest release is #{github_tag}")
          UI.error("")
          UI.error("üîß To fix, run: fastlane sync_version_with_github")
          UI.user_error!("Version synchronization required")
        else
          UI.success("‚úÖ Versions are synchronized")
          UI.success("   UI will display: v#{plist_version}")
          UI.success("   GitHub release: #{github_tag}")
        end
        
      rescue => exception
        UI.error("‚ùå GitHub CLI not available or authentication failed")
        raise exception
      end
    end
  end

  desc "üîÑ Sync version with latest GitHub release"
  lane :sync_version_with_github do |options|
    UI.header "üîÑ Syncing Version with GitHub"
    
    # Ensure we're in project root
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      begin
        # Try GitHub CLI first
        latest_release = sh("gh release list --limit 1 --json tagName --jq '.[0].tagName'", log: false).strip
        version = latest_release.gsub(/^v/, '')
        
        UI.message("üì¶ Latest GitHub release: #{latest_release}")
        UI.message("üìù Extracted version: #{version}")
        
      rescue => gh_exception
        # Fallback to git tags if GitHub CLI fails
        UI.message("‚ö†Ô∏è  GitHub CLI unavailable, falling back to git tags...")
        begin
          latest_tag = sh("git describe --tags --abbrev=0", log: false).strip
          version = latest_tag.gsub(/^v/, '')
          UI.message("üì¶ Latest git tag: #{latest_tag}")
          UI.message("üìù Extracted version: #{version}")
        rescue => git_exception
          if options[:auto_sync]
            UI.error("‚ùå Cannot determine latest version (GitHub CLI and git tags both failed)")
            raise "Auto-sync failed: No version source available"
          else
            UI.error("‚ùå GitHub CLI not available or not authenticated")
            UI.message("Install GitHub CLI: brew install gh")
            UI.message("Authenticate: gh auth login")
            raise gh_exception
          end
        end
      end
      
      # Get current Info.plist version
      current_version = sh("/usr/libexec/PlistBuddy -c 'Print CFBundleShortVersionString' ClickIt/Info.plist", log: false).strip
      
      if version != current_version
        UI.message("‚ö†Ô∏è  Version mismatch detected!")
        UI.message("   Info.plist: #{current_version}")
        UI.message("   Latest release/tag: #{version}")
        UI.message("")
        UI.message("üîß Updating Info.plist to match latest version...")
        
        # Update Info.plist
        sh("/usr/libexec/PlistBuddy -c 'Set CFBundleShortVersionString #{version}' ClickIt/Info.plist")
        
        UI.success("‚úÖ Info.plist updated to v#{version}")
        UI.success("üîÑ UI will now display v#{version}")
      else
        UI.success("‚úÖ Versions are synchronized (v#{version})")
      end
    end
  end

  error do |lane, exception|
    UI.error("‚ùå Lane '#{lane}' failed with error: #{exception.message}")
  end
end
